from datetime import datetime

from bson.objectid import ObjectId
from flask_restful import Resource, request, reqparse

from config import MongoConfig, APIConfig
from model import connection


class CommentsList(Resource):
    def get(self, theme_id):  # get all comments
        parser = reqparse.RequestParser()
        parser.add_argument('page',
                            type=int,
                            help='page number must be int')
        args = parser.parse_args()
        if args['page'] is None:
            args['page'] = 1
        index = args['page'] - 1
        collection = connection[MongoConfig.DB]["comments_" + theme_id]
        cursor = collection.Comments.find(
            skip=(index * APIConfig.PAGESIZE),
            limit=APIConfig.PAGESIZE,
            max_scan=APIConfig.MAX_SCAN,
            sort=[("_created", -1)]
        )  # sorted by create time in reversed order
        return cursor

    def post(self, theme_id):  # add a new comment
        utctime = datetime.timestamp(datetime.utcnow())
        resp = request.get_json(force=True)
        # save a comment
        collection = connection[MongoConfig.DB]["comments_" + theme_id]
        doc = collection.Comments()
        for item in resp:
            doc[item] = resp[item]
        doc['_created'] = utctime
        # 如果之前回复过该贴, 头像保持原状
        cursor = collection.find_one(
            {
                "post_id": resp["post_id"],
                "author": resp["author"]
            }
        )
        if cursor:
            doc["mask_id"] = resp["mask_id"]
        doc.save()
        # save a record
        user_comments = connection.UserComments()
        user_comments['user_id'] = doc['author']
        user_comments['theme_id'] = theme_id
        user_comments['comment_id'] = doc['_id']
        user_comments['_created'] = utctime
        user_comments.save()
        # comment_count +1 when a new comment posted
        collection = connection[MongoConfig.DB]["posts_" + theme_id]
        collection.find_and_modify(
            {"_id": ObjectId(resp['post_id'])},
            {
                "$inc": {
                    "comment_count": 1
                }
            }
        )
        return {"_id": doc['_id']}, 201  # return comment_id generated by system


class Comment(Resource):
    def get(self, theme_id, comment_id):  # get a comment by its ID
        collection = connection[MongoConfig.DB]["comments_" + theme_id]
        cursor = collection.Comments.find_one({"_id": ObjectId(comment_id)})
        return cursor

    def put(self, theme_id, comment_id):  # update a comment by its ID
        resp = request.get_json(force=True)
        if not resp:
            return {'message': 'No input data provided!'}, 400
        elif ("_id" or "_created") in resp:
            resp = {i: resp[i] for i in resp if i not in ("_id", "_created")}
        collection = connection[MongoConfig.DB]["comments_" + theme_id]
        collection.Comments.find_and_modify(
            {"_id": ObjectId(comment_id)},
            {
                "$set": resp
            }
        )
        return None, 204

    def delete(self, theme_id, comment_id):  # delete a comment by its ID
        collection = connection[MongoConfig.DB]["comments_" + theme_id]
        collection.Comments.find_and_modify(
            {"_id": ObjectId(comment_id)}, remove=True)
        return None, 204


class PostComments(Resource):
    def get(self, theme_id, post_id):  # get a post's comments
        parser = reqparse.RequestParser()
        parser.add_argument('page',
                            type=int,
                            help='page number must be int')
        args = parser.parse_args()
        if args['page'] is None:
            args['page'] = 1
        index = args['page'] - 1
        collection = connection[MongoConfig.DB]["comments_" + theme_id]
        cursor = collection.Comments.find(
            {
                "post_id": post_id
            },
            skip=(index * APIConfig.PAGESIZE),
            limit=APIConfig.PAGESIZE,
            max_scan=APIConfig.MAX_SCAN,
            sort=[("_created", 1)]
        )  # sort the result by ascending time
        return cursor
